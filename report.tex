\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{float}
\usepackage{geometry}

\geometry{margin=1in}

\title{ESP32 Advanced Closed-Loop Motor Control System: Comprehensive Technical Report}
\author{ESW Project Team}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Executive Summary}
This document serves as a comprehensive technical report for the ESP32-based Closed-Loop Motor Control System. The project aims to design, implement, and validate a robust control system capable of precise speed regulation (RPM) and position tracking (Angle). The system leverages a hybrid Feedforward-Feedback architecture, utilizing a PID controller augmented with a linear feedforward model.

A key innovation in this project is the integration of an \textbf{Automatic Tuning System} based on the Relay Method (Astrom-Hagglund), allowing the controller to self-optimize its parameters. Furthermore, the system features a "Digital Twin" web interface that not only visualizes real-time telemetry but also runs a kinematic \textbf{Car Simulation} driven by the physical motor's state.

This report details the hardware design, software architecture, control theory, tuning methodologies (Ziegler-Nichols vs. Tyler-Rubinson), and the implementation of the car simulation.

\section{Introduction}

\subsection{Project Objectives}
The primary objectives of this project were:
\begin{enumerate}
    \item \textbf{Precision Control}: Achieve stable speed control under varying loads and precise position holding.
    \item \textbf{Connectivity}: Implement IoT capabilities using MQTT to allow remote monitoring and control.
    \item \textbf{Self-Optimization}: Develop an algorithm to automatically determine optimal PID gains ($K_p, K_i, K_d$).
    \item \textbf{Simulation}: Create a virtual representation (Car Simulation) that mirrors the physical motor's behavior.
\end{enumerate}

\subsection{Scope}
The scope includes the embedded firmware development (C++/Arduino), the control algorithm design, the web application development (JavaScript/HTML5), and the physical wiring of the ESP32, L298N driver, and DC motor with encoder.

\section{System Hardware Architecture}

\subsection{Microcontroller: ESP32}
We selected the ESP32 for its dual-core architecture running at 240MHz, which allows us to dedicate resources to the high-frequency control loop while simultaneously handling WiFi/MQTT communication stacks without jitter.

\subsection{Actuator: DC Motor \& Driver}
\begin{itemize}
    \item \textbf{Motor}: A standard 12V DC Gear Motor.
    \item \textbf{Driver}: L298N H-Bridge module. This allows for bidirectional control (Forward/Reverse) by manipulating the logic levels of input pins (\texttt{IN1}, \texttt{IN2}) and the speed via Pulse Width Modulation (PWM) on the \texttt{Enable} pin.
\end{itemize}

\subsection{Sensor: Quadrature Encoder}
Feedback is provided by a magnetic/optical quadrature encoder attached to the motor shaft.
\begin{itemize}
    \item \textbf{Resolution}: The encoder has a base resolution of 600 Pulses Per Revolution (PPR).
    \item \textbf{Decoding}: We utilize \textbf{4x Decoding} in software, triggering interrupts on both rising and falling edges of both channels (A and B). This yields an effective resolution of $600 \times 4 = 2400$ counts per revolution, providing 0.15$^{\circ}$ of angular precision.
\end{itemize}

\section{Software Architecture}

The firmware (\texttt{code.ino}) is structured as a non-blocking, event-driven system. It avoids the use of \texttt{delay()} to ensure the control loop maintains a strict timing guarantee.

\subsection{The Main Loop}
The \texttt{loop()} function orchestrates three parallel tasks:
\begin{enumerate}
    \item \textbf{Network Task}: Checks MQTT connection and processes incoming packets.
    \item \textbf{Command Task}: Listens for Serial input for debugging.
    \item \textbf{Control Task}: Runs exactly every 100ms (\texttt{controlIntervalMs}). This is the "heartbeat" of the system.
\end{enumerate}

\subsection{State Machine}
The system behavior is governed by a finite state machine (\texttt{ControlState} enum):
\begin{itemize}
    \item \texttt{STATE\_PID\_RUNNING}: Normal speed control mode.
    \item \texttt{STATE\_POSITION\_CONTROL}: Position/Angle holding mode.
    \item \texttt{STATE\_AUTOTUNE\_START}: Initialization of the tuning sequence.
    \item \texttt{STATE\_AUTOTUNE\_RELAY\_STEP}: Active execution of the relay oscillation.
\end{itemize}

\subsection{Communication Architecture: MQTT over TLS}

The system implements secure MQTT communication using TLS encryption for production deployment.

\textbf{ESP32 Side (Firmware):}
\begin{itemize}
    \item \textbf{Library}: \texttt{WiFiClientSecure} - Provides TLS/SSL encrypted WiFi connections
    \item \textbf{Broker}: HiveMQ Cloud at \texttt{4809a06803844080a705e76187cf49ce.s1.eu.hivemq.cloud}
    \item \textbf{Port}: 8883 (MQTT over TLS)
    \item \textbf{Authentication}: Username/password authentication (\texttt{DC\_Motor/EWS\_Lab4})
    \item \textbf{Message Format}: JSON serialization via \texttt{ArduinoJson} library
\end{itemize}

\textbf{Web Dashboard Side (JavaScript):}
\begin{itemize}
    \item \textbf{Library}: \texttt{mqtt.js} - JavaScript MQTT client
    \item \textbf{Protocol}: WebSocket Secure (wss://)
    \item \textbf{Port}: 8884 (WebSocket over TLS)
    \item \textbf{Message Format}: JSON parsing with native JavaScript
\end{itemize}

\textbf{MQTT Topics:}
\begin{verbatim}
esp32/motor/data      - Telemetry (currentRPM, targetRPM, PWM, gains)
esp32/motor/control   - Commands (targetRPM, targetAngle, tune, pidMode)
esp32/motor/status    - Status messages (autotune progress, errors)
\end{verbatim}

\textbf{Code Example (ESP32 Message Publishing):}
\begin{verbatim}
// From publishMotorData() in code.ino
DynamicJsonDocument doc(512);
doc["currentRPM"] = rpmFiltered;
doc["targetRPM"] = targetRPM;
doc["pwmValue"] = currentPWM;
doc["Kp"] = Kp; 
doc["Ki"] = Ki; 
doc["Kd"] = Kd;
doc["posKp"] = posKp;
doc["posKi"] = posKi;
doc["posKd"] = posKd;
String payload;
serializeJson(doc, payload);
mqttClient.publish(TOPIC_MOTOR_DATA, payload.c_str());
\end{verbatim}

This architecture allows remote control and monitoring from anywhere with internet access while maintaining security through TLS encryption.

\section{Control Theory \& Implementation}

We implemented a \textbf{Single-Loop PID Controller} with an added \textbf{Feedforward} term.

\subsection{PID Mode Switching: Experimental Control Strategies}

A unique feature of this system is the ability to dynamically switch between three control modes during runtime, allowing for educational comparison of different control strategies:

\begin{enumerate}
    \item \textbf{P-only Mode} (Proportional Only):
    \begin{itemize}
        \item Configuration: $K_i = 0$, $K_d = 0$
        \item Behavior: Fast initial response, significant overshoot ($>$20\%), steady-state error
        \item Use case: When rapid initial reaction is prioritized over accuracy
    \end{itemize}
    
    \item \textbf{PI-only Mode} (Proportional + Integral):
    \begin{itemize}
        \item Configuration: $K_d = 0$
        \item Behavior: Eliminates steady-state error, prone to oscillations, slower settling
        \item Use case: When zero steady-state error is required but derivative noise is problematic
    \end{itemize}
    
    \item \textbf{Full PID Mode}:
    \begin{itemize}
        \item Configuration: All three terms active
        \item Behavior: Optimal performance - minimal overshoot, fast settling, no steady-state error
        \item Use case: Default mode for best overall performance
    \end{itemize}
\end{enumerate}

\textbf{Implementation (code.ino lines 269-291):}
\begin{verbatim}
enum PIDMode {
  MODE_P_ONLY,      // Ki=0, Kd=0
  MODE_PI_ONLY,     // Kd=0
  MODE_PID_FULL     // Full PID
};

void setPIDMode(PIDMode mode) {
  currentPIDMode = mode;
  integral = 0;  // Reset integral when changing modes
  prevError = 0;
  updatePIDGains();
}

void updatePIDGains() {
  switch (currentPIDMode) {
    case MODE_P_ONLY:
      Kp = Kp_base; Ki = 0.0; Kd = 0.0;
      break;
    case MODE_PI_ONLY:
      Kp = Kp_base; Ki = Ki_base; Kd = 0.0;
      break;
    case MODE_PID_FULL:
      Kp = Kp_base; Ki = Ki_base; Kd = Kd_base;
      break;
  }
}
\end{verbatim}

The web dashboard includes a \textbf{PID Comparison Chart} that overlays the step responses of all three modes on the same graph, similar to the temperature control example demonstrated in class. This allows for direct visual comparison of overshoot, settling time, and steady-state error across different control strategies.

\subsection{RPM Control \& PWM Scaling (-300 to +300 RPM)}
The system is designed to control the motor speed across a full bidirectional range of \textbf{-300 RPM to +300 RPM}.

\textbf{PWM Scaling Logic:}
To achieve this, we characterized the motor's response curve. The relationship between the Pulse Width Modulation (PWM) duty cycle (0-255) and the resulting Speed (RPM) is non-linear and load-dependent.
\begin{itemize}
    \item \textbf{Forward (+)}: Target RPM > 0. Logic: \texttt{IN1=HIGH, IN2=LOW}.
    \item \textbf{Reverse (-)}: Target RPM < 0. Logic: \texttt{IN1=LOW, IN2=HIGH}.
\end{itemize}

We implemented a lookup table in \texttt{code.ino} that maps specific PWM values to measured RPMs.
\begin{verbatim}
// From code.ino
float calibPWM[] = {25, 30, ..., 255};
float calibRPM[] = {7.6, 27.5, ..., 317.0};
\end{verbatim}
The function \texttt{pwmFromRPM(targetRPM)} uses linear interpolation on this graph to find the Feedforward PWM.
\begin{itemize}
    \item \textit{Example}: If target is 150 RPM, and the table has points (130 RPM @ 50 PWM) and (170 RPM @ 60 PWM), the function interpolates to find the exact PWM required.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig_rpm_pwm_calibration.png}
    \caption{RPM vs PWM Calibration Curve}
    \label{fig:calib_curve}
\end{figure}

\subsection{Feedback Control (PID)}
The core control logic calculates the error ($e(t) = Setpoint - ProcessVariable$) and applies corrections based on three terms:

\begin{enumerate}
    \item \textbf{Proportional (P)}: Reacts to the current error. $K_p \times e(t)$.
    \item \textbf{Integral (I)}: Reacts to the accumulation of past errors (eliminates steady-state error). $K_i \times \int e(t) dt$.
    \item \textbf{Derivative (D)}: Reacts to the rate of change of error (predicts future error). $K_d \times \frac{de(t)}{dt}$.
\end{enumerate}

\textbf{Code Implementation:}
\begin{verbatim}
// From runPIDControl() in code.ino
double correction = Kp * error + Ki * integral + Kd * derivative;
int pwmFF = pwmFromRPM(targetRPM); // Feedforward from Curve
int pwmVal = pwmFF + (int)correction; // Combined Output
\end{verbatim}

\textbf{Mathematical Formulation:}
\[ u(t) = K_p e(t) + K_i \int_0^t e(\tau)d\tau + K_d \frac{de(t)}{dt} \]

\section{Position Control Implementation}

Position control requires tracking the absolute angular displacement of the shaft. Unlike speed control, which resets the encoder count every loop, position control relies on a cumulative counter.

\subsection{Variable Tracking}
\begin{itemize}
    \item \texttt{totalEncoderCount}: A \texttt{volatile long} that increments/decrements with every encoder pulse, never resetting.
    \item \texttt{currentAngle}: Calculated as \texttt{(totalEncoderCount / 2400.0) * 360.0}.
\end{itemize}

\subsection{Control Logic (\texttt{runPositionControl})}
This function (lines 328-359) implements a dedicated PID loop for position.

\textbf{Code Walkthrough:}
\begin{enumerate}
    \item \textbf{Angle Calculation}:
    \begin{verbatim}
currentAngle = ((float)totalEncoderCount / (float)COUNTS_PER_REV) * 360.0;
    \end{verbatim}
    \item \textbf{Error Computation}:
    \begin{verbatim}
double error = targetAngle - currentAngle;
    \end{verbatim}
    \item \textbf{PID Calculation}:
    Uses a separate set of gains (\texttt{posKp}, \texttt{posKi}, \texttt{posKd}) specifically tuned for position holding. Position control typically requires a higher $K_p$ (stiffness) and lower $K_i$ compared to speed control.
    \item \textbf{Direction Logic}:
    The sign of the error determines the motor direction.
    \begin{verbatim}
if (error > 0) { /* Drive Forward */ }
else if (error < 0) { /* Drive Reverse */ }
    \end{verbatim}
    \item \textbf{Deadband (Hysteresis)}:
    To prevent the motor from "hunting" (oscillating endlessly) around the target due to quantization noise, we implement a deadband.
    \begin{verbatim}
if (abs(error) < 2.0) {
    stopMotor();
    // ...
}
    \end{verbatim}
    If the motor is within 2 degrees of the target, it shuts off.
\end{enumerate}

% Position step-response figure intentionally removed per final report scope.

\section{Web Dashboard Architecture}

The project includes a comprehensive web-based dashboard (\texttt{index.html}, \texttt{script.js}) that provides real-time monitoring, control, and data visualization capabilities.

\subsection{Technology Stack}
\begin{itemize}
    \item \textbf{Frontend Framework}: Vanilla JavaScript (ES6+) with modular architecture
    \item \textbf{MQTT Client}: \texttt{mqtt.js} library for WebSocket-based MQTT communication
    \item \textbf{Charting Library}: \texttt{Chart.js} for real-time data visualization
    \item \textbf{Styling}: Custom CSS with gradient themes and responsive design
    \item \textbf{Icons}: Font Awesome 6.0 for consistent UI elements
\end{itemize}

\subsection{Real-time Data Visualization}

The dashboard implements \textbf{eight specialized charts} for comprehensive analysis:

\begin{enumerate}
    \item \textbf{RPM vs Time Chart} (Auto-scaled):
    \begin{itemize}
        \item Plots target RPM (setpoint) and actual RPM (process variable)
        \item Integer step scaling (steps of 1 RPM) for precise oscillation visibility
        \item Dynamically adjusts Y-axis to show control dynamics clearly
        \item Supports CSV export for post-processing and PNG export for reports
    \end{itemize}
    
    \item \textbf{PWM vs Time Chart}:
    \begin{itemize}
        \item Shows the control effort (PWM duty cycle 0-255)
        \item Fixed Y-axis range for consistent visualization
        \item Helps identify saturation (PWM = 255) and deadband regions
    \end{itemize}
    
    \item \textbf{Calibration Oscillations Chart}:
    \begin{itemize}
        \item Records ONLY during autotuning process
        \item Fixed 100-200 RPM range centered around 150 RPM setpoint
        \item Shows 150 RPM baseline (red dashed line) for reference
        \item Captures the relay-induced limit cycle for $K_u$ and $T_u$ calculation
        \item Manual clear button to reset before new calibration runs
    \end{itemize}
    
    \item \textbf{PID Comparison Chart} (Educational):
    \begin{itemize}
        \item Overlays P-only (red), PI-only (orange), and Full PID (purple) responses
        \item Shows setpoint as blue dashed line (like temperature control examples)
        \item Time axis in seconds elapsed for direct comparison
        \item Auto-scaled Y-axis with integer steps for clarity
        \item Demonstrates overshoot, settling time, and steady-state error differences
    \end{itemize}
    
    \item \textbf{Individual PID Mode Charts} (3 charts):
    \begin{itemize}
        \item Separate detailed charts for P-only, PI-only, and Full PID
        \item Each chart shows target RPM (setpoint) vs actual response
        \item Color-coded: Red for P, Orange for PI, Purple for PID
        \item Independent CSV/PNG export for each mode
        \item Batch clear button to reset all three simultaneously
    \end{itemize}
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig_p_only_rpm_time.png}
    \caption{P-only Control: RPM vs Time}
    \label{fig:p_only_rpm_time}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig_pi_only_rpm_time.png}
    \caption{PI-only Control: RPM vs Time}
    \label{fig:pi_only_rpm_time}
\end{figure}

\subsection{Data Export Capabilities}

All charts support dual export formats:
\begin{itemize}
    \item \textbf{PNG Export}: High-resolution chart images for reports and presentations
    \item \textbf{CSV Export}: Raw timestamped data for MATLAB/Python/Excel analysis
\end{itemize}

\textbf{CSV Format Example:}
\begin{verbatim}
Time,Target RPM,Current RPM
10:23:45,150,148.5
10:23:46,150,151.2
...
\end{verbatim}

This enables reproducible analysis and comparison with theoretical models.

\section{Car Simulation (The Digital Twin)}

A unique feature of this project is the \textbf{Car Simulation} embedded in a separate web page (\texttt{mqtt-simulation.html} and \texttt{mqtt-simulation.js}). This acts as a visual verification tool, translating raw motor metrics into a relatable physical model.

\subsection{Kinematic Model}
The simulation models a 2D vehicle on a Cartesian plane.
\begin{itemize}
    \item \textbf{State Vector}: $[x, y, \theta, v]^T$
    \begin{itemize}
        \item $x, y$: Position coordinates (pixels).
        \item $\theta$: Heading angle (degrees).
        \item $v$: Linear velocity (pixels/frame).
    \end{itemize}
\end{itemize}

\subsection{Simulation Mapping: RPM to Speed, Angle to Turn}
The digital twin maps the physical motor states directly to the virtual car's kinematics. This creates a direct "Hardware-in-the-Loop" feel.

\textbf{1. RPM \textrightarrow{} Car Speed}
The motor's rotational speed controls the car's linear velocity.
\begin{itemize}
    \item \textbf{Physical Range}: -300 RPM to +300 RPM.
    \item \textbf{Simulation Logic}:
    \[ v_{car} = \frac{RPM_{motor}}{100} \]
    \item \textbf{Effect}:
    \begin{itemize}
        \item \textbf{+300 RPM}: Car moves forward fast (3 pixels/frame).
        \item \textbf{-300 RPM}: Car reverses fast (-3 pixels/frame).
        \item \textbf{0 RPM}: Car stops.
    \end{itemize}
\end{itemize}

\textbf{2. Motor Angle \textrightarrow{} Car Turn (Steering)}
The motor's absolute position controls the car's heading.
\begin{itemize}
    \item \textbf{Physical Input}: \texttt{targetAngle} or \texttt{currentAngle} (Degrees).
    \item \textbf{Simulation Logic}:
    \[ \theta_{car} = \theta_{motor} \]
    \item \textbf{Effect}:
    \begin{itemize}
        \item Rotating the motor to \textbf{90$^{\circ}$} turns the car to face \textbf{Down}.
        \item Rotating the motor to \textbf{180$^{\circ}$} turns the car to face \textbf{Left}.
    \end{itemize}
\end{itemize}

\subsection{Implementation (\texttt{mqtt-simulation.js})}
The physics update loop runs via \texttt{requestAnimationFrame}.

\textbf{Update Logic (lines 199-213):}
\begin{verbatim}
function updateCarPosition() {
    // Convert degrees to radians for Math functions
    const angleRad = (carState.angle * Math.PI) / 180;
    
    // Calculate velocity components
    carState.x += carState.speed * Math.cos(angleRad);
    carState.y += carState.speed * Math.sin(angleRad);
    
    // Screen Wrap-around logic
    if (carState.x > canvas.width) carState.x = 0;
    // ...
}
\end{verbatim}
This creates a direct visual link: if the physical motor spins faster, the virtual car moves faster. If the physical motor rotates to a specific angle, the virtual car steers.

\begin{figure}[H]
    \centering
    \fbox{\parbox{0.8\textwidth}{\centering \vspace{2cm} [GRAPH PLACEHOLDER: Simulation Screenshot] \\ Insert a screenshot of the car simulation interface. \vspace{2cm}}}
    \caption{Simulation Screenshot}
    \label{fig:sim_screenshot}
\end{figure}

\section{Automatic Tuning \& Method Comparison}

\subsection{The Relay Method}
We implemented the Relay Method to auto-tune the PID gains. This involves replacing the PID controller with a relay that switches the motor output between $+Output$ and $-Output$ based on the error sign. This induces a \textbf{Limit Cycle Oscillation}.

By measuring the amplitude ($a$) and period ($T_u$) of this oscillation, we calculate the \textbf{Ultimate Gain} ($K_u$):
\[ K_u = \frac{4d}{\pi a} \]

where $d$ is the relay amplitude (TUNE\_RELAY\_AMP = 50) and $a$ is the measured oscillation amplitude.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig_autotune_limit_cycle.png}
    \caption{Relay Method Autotuning Oscillation}
    \label{fig:autotune_limit_cycle}
\end{figure}

\subsection{Dual-Mode Autotuning: Speed vs. Position}

\textbf{Critical Innovation:} Our system implements \textit{separate autotuning modes} for speed and position control, recognizing that these are fundamentally different control problems.

\begin{itemize}
    \item \textbf{Speed Control:} Regulates velocity (rate of change)
    \item \textbf{Position Control:} Regulates absolute position (integrated quantity)
\end{itemize}

The firmware supports two commands:
\begin{itemize}
    \item \texttt{tuneSpeed}: Tunes Kp\_base, Ki\_base, Kd\_base for velocity control
    \item \texttt{tunePosition}: Tunes posKp, posKi, posKd for position/servo control
\end{itemize}

\subsection{Comparison: Ziegler-Nichols vs. Tyler-Rubinson}

We evaluated two tuning rules based on the derived $K_u$ and $T_u$.

\subsubsection{Method 1: Ziegler-Nichols (ZN)}
\begin{itemize}
    \item \textbf{Philosophy}: Aggressive. Aims for 1/4 amplitude decay.
    \item \textbf{Gains}: High $K_p$, High $K_i$, Moderate $K_d$.
    \item \textbf{Result}: The motor reacts instantly to setpoint changes. However, it exhibits significant overshoot ($\sim$25\%) and ringing.
    \item \textbf{Suitability}: Best for disturbance rejection in systems where overshoot is tolerable.
\end{itemize}

\subsubsection{Method 2: Tyler-Rubinson (Tyreus-Luyben)}
\begin{itemize}
    \item \textbf{Philosophy}: Conservative. Aims for stability and robustness.
    \item \textbf{Gains}:
    \begin{itemize}
        \item $K_p = 0.45 K_u$ (Reduced proportional action).
        \item $K_i = K_p / (2.2 T_u)$ (Significantly reduced integral action).
    \end{itemize}
    \item \textbf{Result}: The response is overdamped. It approaches the setpoint slowly but with zero overshoot.
    \item \textbf{Suitability}: Best for processes where overshoot is dangerous (e.g., chemical reactors) or mechanical stress must be minimized.
\end{itemize}

\subsection{Final Decision}
We chose \textbf{Ziegler-Nichols} for this application.
\begin{itemize}
    \item \textbf{Reasoning}: In a DC motor speed control context, "sluggishness" feels unresponsive to the user. The Tyler-Rubinson method made the motor feel laggy. The overshoot from ZN was deemed acceptable and was further mitigated by the feedforward term and the input filter (\texttt{alpha = 0.4}).
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fig_pid_rpm_time.png}
    \caption{Full PID: RPM vs Time}
    \label{fig:pid_rpm_time}
\end{figure}

\subsection{Position Autotuning: Modified Ziegler-Nichols for Servo Systems}

Position control requires fundamentally different tuning because it regulates an \textit{integrated quantity} (position = $\int$ velocity). Direct application of speed-tuned gains causes:
\begin{itemize}
    \item \textbf{Integral Windup:} Large position errors accumulate massive integral terms
    \item \textbf{Sustained Oscillations:} Especially at large angles (e.g., 360°)
    \item \textbf{Poor Damping:} Insufficient derivative action for position dynamics
\end{itemize}

\subsubsection{Modified Ziegler-Nichols Formulas for Position Control}

After relay autotuning derives $K_u$ and $T_u$ at the same operating point (150 RPM), we apply \textbf{different scaling factors} for position gains:

\textbf{Speed Control (Standard Ziegler-Nichols):}
\begin{align}
    K_p &= 0.6 \times K_u \\
    K_i &= \frac{K_p}{T_u / 2.0} = \frac{2 K_p}{T_u} \\
    K_d &= \frac{K_p \times T_u}{8.0}
\end{align}

\textbf{Position Control (Modified ZN for Servo):}
\begin{align}
    \text{posKp} &= 0.8 \times K_u \quad \text{(33\% higher for stiffness)} \\
    \text{posKi} &= \frac{\text{posKp}}{4.0 \times T_u} \quad \text{(4$\times$ lower to prevent windup)} \\
    \text{posKd} &= \frac{\text{posKp} \times T_u}{4.0} \quad \text{(2$\times$ higher for damping)}
\end{align}

\textbf{Code Implementation (lines 406-433 in \texttt{code.ino}):}
\begin{verbatim}
if (autotuneTarget == TUNE_SPEED) {
    // Ziegler-Nichols for Speed Control
    Kp_base = 0.6 * Ku;
    Ki_base = Kp_base / (Tu_sec / 2.0);
    Kd_base = Kp_base * (Tu_sec / 8.0);
} else {
    // Modified Ziegler-Nichols for Position/Servo Control
    posKp = 0.8 * Ku;              // More aggressive proportional
    posKi = posKp / (4.0 * Tu_sec); // Much lower integral
    posKd = posKp * (Tu_sec / 4.0); // Higher derivative
}
\end{verbatim}

\textbf{Rationale Table:}
\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|l|}
\hline
\textbf{Gain} & \textbf{Speed} & \textbf{Position} & \textbf{Reason} \\
\hline
$K_p$ & $0.6 K_u$ & $0.8 K_u$ & Position needs stiffer response \\
$K_i$ & $2K_p/T_u$ & $K_p/(4T_u)$ & Prevent integral windup on large errors \\
$K_d$ & $K_pT_u/8$ & $K_pT_u/4$ & More damping for position dynamics \\
\hline
\end{tabular}
\caption{Comparison of Speed vs. Position Tuning Formulas}
\end{table}

\section{Detailed Code Analysis}

This section provides a line-by-line breakdown of critical code segments.

\subsection{Interrupt Service Routine (ISR)}
\begin{verbatim}
// Lines 45-54
void IRAM_ATTR encoderISR() {
  uint8_t a = digitalRead(ENCODER_A);
  uint8_t b = digitalRead(ENCODER_B);
  uint8_t ab = (a << 1) | b;
  uint8_t idx = (lastAB << 2) | ab;
  int8_t delta = qdelta[idx];
  encoderCount += delta;
  totalEncoderCount += delta;
  lastAB = ab;
}
\end{verbatim}
\begin{itemize}
    \item \textbf{\texttt{IRAM\_ATTR}}: This attribute places the function in the ESP32's Instruction RAM (IRAM) rather than Flash memory. This is critical for ISRs to prevent crashes during Flash write operations and to ensure deterministic execution time.
    \item \textbf{Lookup Table (\texttt{qdelta})}: Instead of complex \texttt{if/else} logic, we use a state lookup table to determine if the encoder moved +1, -1, or 0 steps based on the transition from \texttt{lastAB} to current \texttt{ab}. This is extremely efficient.
\end{itemize}

\subsection{RPM Calculation}
\begin{verbatim}
// Lines 223-234
if (now - lastControlMs >= controlIntervalMs) {
    noInterrupts();
    long cnt = encoderCount;
    encoderCount = 0;
    interrupts();
    
    float revolutions = (float)cnt / (float)COUNTS_PER_REV;
    float rpm = (revolutions * 60000.0f / elapsed);
}
\end{verbatim}
\begin{itemize}
    \item \textbf{Critical Section}: The \texttt{noInterrupts()} / \texttt{interrupts()} block is essential. \texttt{encoderCount} is a multi-byte variable (long). If an interrupt occurred while the processor was reading byte 1 of 4, the value would be corrupted (Atomicity violation). Disabling interrupts briefly ensures data integrity.
\end{itemize}


\section{Deep Dive: Quadrature Encoder Logic}

The user asked: \textit{"How do we decide which direction to move?"}
This is determined by the \textbf{Quadrature Encoder} logic. The encoder has two output channels, \textbf{A} and \textbf{B}. Inside the encoder, there are two sensors positioned such that their signals are \textbf{90 degrees out of phase} (offset by 1/4 of a cycle).

\subsection{The Phase Shift (Crest and Trough)}
Imagine two square waves. When Channel A is at its "crest" (High), Channel B might be rising or falling depending on the direction.
\begin{itemize}
    \item \textbf{Clockwise (CW)}: A leads B. The sequence of states (A,B) is: \texttt{00 \textrightarrow{} 10 \textrightarrow{} 11 \textrightarrow{} 01 \textrightarrow{} 00}.
    \item \textbf{Counter-Clockwise (CCW)}: B leads A. The sequence is: \texttt{00 \textrightarrow{} 01 \textrightarrow{} 11 \textrightarrow{} 10 \textrightarrow{} 00}.
\end{itemize}

\subsection{The Lookup Table Implementation}
In \texttt{code.ino}, we use a highly efficient \textbf{Lookup Table} method to decode these states inside the Interrupt Service Routine (ISR).

\textbf{Code Analysis (\texttt{code.ino} lines 40-54):}
\begin{verbatim}
// The Lookup Table
const int8_t qdelta[16] = {
  0,  1, -1,  0, -1,  0,  0,  1,
  1,  0,  0, -1,  0, -1,  1,  0
};

void IRAM_ATTR encoderISR() {
  uint8_t a = digitalRead(ENCODER_A);
  uint8_t b = digitalRead(ENCODER_B);
  uint8_t ab = (a << 1) | b;      // Current State (2 bits)
  uint8_t idx = (lastAB << 2) | ab; // Index = PreviousState (2 bits) + CurrentState (2 bits)
  int8_t delta = qdelta[idx];     // Look up direction (+1, -1, or 0)
  encoderCount += delta;
  lastAB = ab;
}
\end{verbatim}

\textbf{How it works:}
\begin{enumerate}
    \item We combine the \textbf{Previous State} (\texttt{lastAB}) and the \textbf{Current State} (\texttt{ab}) into a 4-bit index (\texttt{idx}).
    \begin{itemize}
        \item Example: Previous was \texttt{00} (0), Current is \texttt{10} (2). Index = \texttt{0010} (2).
    \end{itemize}
    \item We look up \texttt{qdelta[2]}.
    \begin{itemize}
        \item If the transition \texttt{00 \textrightarrow{} 10} corresponds to Forward, \texttt{qdelta[2]} will be \texttt{1}.
        \item If the transition \texttt{00 \textrightarrow{} 01} corresponds to Reverse, \texttt{qdelta[1]} will be \texttt{-1}.
        \item Invalid transitions (e.g., \texttt{00 \textrightarrow{} 11}, jumping two steps at once) return \texttt{0}.
    \end{itemize}
\end{enumerate}

This method is extremely fast (O(1) complexity) and robust against contact bounce, making it ideal for high-speed motor control.

\section{Deep Dive: Autotuning Implementation}

The most complex feature of this system is the \textbf{Dual-Mode Relay Autotuner}, which automatically identifies the plant's transfer function characteristics and applies appropriate tuning formulas based on the control objective (speed vs. position). This section analyzes the \texttt{runAutotuner()} function in \texttt{code.ino} (lines 371-441) line-by-line.

\subsection{The Relay Logic (Forcing Oscillation)}
The core principle is to force the system into a stable limit cycle. Instead of a PID output, we apply a "Bang-Bang" control with a fixed amplitude around the setpoint.

\begin{verbatim}
// Lines 363-365
int pwmFF = pwmFromRPM(TUNE_SETPOINT_RPM);
int pwmVal = (rpmFiltered < TUNE_SETPOINT_RPM) ? (pwmFF + TUNE_RELAY_AMP) : (pwmFF - TUNE_RELAY_AMP);
pwmVal = constrain(pwmVal, 0, 255);
\end{verbatim}
\begin{itemize}
    \item \textbf{Line 363}: We calculate the feedforward PWM for the tuning setpoint (e.g., 150 RPM). This centers our relay oscillation around the motor's natural operating point.
    \item \textbf{Line 364}: This is the Relay.
    \begin{itemize}
        \item If speed < target, we boost power: \texttt{Base + Amplitude}.
        \item If speed > target, we cut power: \texttt{Base - Amplitude}.
        \item \texttt{TUNE\_RELAY\_AMP} is set to 50, meaning we swing the PWM by $\pm$50.
    \end{itemize}
\end{itemize}

\subsection{Cycle Detection (Zero Crossing)}
To measure the period of oscillation ($T_u$), we need to detect when the RPM crosses the setpoint.

\begin{verbatim}
// Lines 370-382
if (lastRpm < TUNE_SETPOINT_RPM && rpmFiltered >= TUNE_SETPOINT_RPM) {
    unsigned long now = millis();
    if (lastCrossingTime > 0) {
        long period_Tu = now - lastCrossingTime;
        crossings++;
        if (crossings > 2) {
            sum_Tu += period_Tu;
            sum_a += (peakRpm - troughRpm) / 2.0;
        }
    }
    lastCrossingTime = now;
    troughRpm = peakRpm; // Reset for next half-cycle
}
\end{verbatim}
\begin{itemize}
    \item \textbf{Line 370}: Detects a \textbf{Rising Edge} crossing (was below, now above).
    \item \textbf{Line 373}: Calculates the time elapsed since the last rising edge. This is the period ($T_u$) of one full cycle.
    \item \textbf{Line 375}: We discard the first 2 crossings to allow the oscillation to stabilize (reach steady-state limit cycle).
    \item \textbf{Line 377}: We accumulate the amplitude ($a$). \texttt{(peakRpm - troughRpm) / 2.0} gives the amplitude from the center.
\end{itemize}

\subsection{Peak/Trough Tracking}
To calculate amplitude, we must find the min and max RPM during each cycle.

\begin{verbatim}
// Lines 384-386
if (rpmFiltered > peakRpm) peakRpm = rpmFiltered;
if (rpmFiltered < troughRpm) troughRpm = rpmFiltered;
lastRpm = rpmFiltered;
\end{verbatim}
This simple logic continuously updates the extremes. These are reset/latched during the crossing event.

\subsection{Gain Calculation: Dual-Mode Implementation}
Once we have collected enough cycles (defined by \texttt{TUNE\_CYCLES = 15}), we compute the PID parameters based on the target control mode.

\begin{verbatim}
// Lines 400-437
if (crossings >= (TUNE_CYCLES + 2)) {
    double avg_Tu_ms = sum_Tu / TUNE_CYCLES;
    double avg_a = sum_a / TUNE_CYCLES;
    
    // Ultimate Gain (Ku) Calculation
    double Ku = (4.0 * TUNE_RELAY_AMP) / (PI * avg_a);
    double Tu_sec = avg_Tu_ms / 1000.0;

    if (autotuneTarget == TUNE_SPEED) {
        // Ziegler-Nichols for Speed Control
        Kp_base = 0.6 * Ku;
        Ki_base = Kp_base / (Tu_sec / 2.0);
        Kd_base = Kp_base * (Tu_sec / 8.0);
        updatePIDGains();
    } else {
        // Modified Ziegler-Nichols for Position/Servo Control
        posKp = 0.8 * Ku;
        posKi = posKp / (4.0 * Tu_sec);
        posKd = posKp * (Tu_sec / 4.0);
    }
}
\end{verbatim}

\begin{itemize}
    \item \textbf{Lines 403-404}: This is the \textbf{Describing Function} derivation for a relay.
    \[ K_u = \frac{4d}{\pi a} \]
    Where $d$ is the relay amplitude (\texttt{TUNE\_RELAY\_AMP}) and $a$ is the measured oscillation amplitude (\texttt{avg\_a}).
    
    \item \textbf{Lines 406-421 (TUNE\_SPEED branch)}: Applies standard Ziegler-Nichols formulas:
    \begin{align*}
        K_p &= 0.6 K_u \\
        K_i &= \frac{2 K_p}{T_u} \\
        K_d &= \frac{K_p T_u}{8}
    \end{align*}
    These gains are stored in \texttt{Kp\_base}, \texttt{Ki\_base}, \texttt{Kd\_base} and applied via \texttt{updatePIDGains()}.
    
    \item \textbf{Lines 422-433 (TUNE\_POSITION branch)}: Applies modified servo-control formulas:
    \begin{align*}
        \text{posKp} &= 0.8 K_u \quad \text{(Higher stiffness)} \\
        \text{posKi} &= \frac{\text{posKp}}{4 T_u} \quad \text{(Lower integral)} \\
        \text{posKd} &= \frac{\text{posKp} T_u}{4} \quad \text{(Higher damping)}
    \end{align*}
    These gains are applied directly to position control without affecting speed control.
\end{itemize}

This automated dual-mode process replaces hours of manual trial-and-error tuning with a 10-second automated routine for \textit{both} speed and position control, recognizing their fundamental differences.

\section{Progressive Web App (PWA) Implementation}

To enable offline access and native app-like experience, the dashboard is implemented as a \textbf{Progressive Web App} using modern web standards.

\subsection{Service Worker Architecture}

The project includes a Service Worker (\texttt{sw.js}) that implements:

\begin{itemize}
    \item \textbf{Cache-First Strategy}: Static assets (HTML, CSS, JS) served from cache for instant loading
    \item \textbf{Network-First for MQTT}: Live data always fetched from network, cached as fallback
    \item \textbf{Automatic Updates}: Cache versioning (\texttt{CACHE\_NAME = 'motor-control-v1.4'}) with old cache cleanup
    \item \textbf{Offline Fallback}: Graceful degradation when network unavailable
\end{itemize}

\textbf{Code Structure (sw.js):}
\begin{verbatim}
const CACHE_NAME = 'motor-control-v1.4';
const urlsToCache = [
  './', 'index.html', 'style.css', 'script.js',
  'mqtt-simulation.html', 'mqtt-simulation.js',
  'manifest.json',
  // CDN resources for offline functionality
  'https://cdnjs.cloudflare.com/.../font-awesome/6.0.0/css/all.min.css',
  'https://unpkg.com/mqtt/dist/mqtt.min.js',
  'https://cdn.jsdelivr.net/npm/chart.js'
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
      .then(() => self.skipWaiting())
  );
});
\end{verbatim}

\subsection{PWA Manifest}

The \texttt{manifest.json} file defines the app's metadata and icon set:

\begin{itemize}
    \item \textbf{Name}: "DC Motor Control Dashboard"
    \item \textbf{Display Mode}: Standalone (no browser chrome)
    \item \textbf{Theme Color}: \texttt{\#0f3460} (matches dashboard header)
    \item \textbf{Icons}: 8 sizes (72×72 to 512×512) for all device resolutions
    \item \textbf{Orientation}: Portrait-primary for mobile devices
\end{itemize}

\subsection{Installation Experience}

When users visit the dashboard, browsers detect the PWA capability and offer installation:

\begin{itemize}
    \item \textbf{Desktop}: "Install App" button in address bar (Chrome/Edge)
    \item \textbf{Mobile}: "Add to Home Screen" prompt with custom banner
    \item \textbf{iOS}: Full PWA support with proper icon placement
\end{itemize}

Once installed, the app:
\begin{itemize}
    \item Launches in fullscreen mode (no browser UI)
    \item Appears in app launcher/home screen with custom icon
    \item Loads instantly from cache (sub-second startup)
    \item Works offline for cached pages (live data requires connection)
    \item Auto-updates in background when new version deployed
\end{itemize}

This transforms the web dashboard into a production-grade application suitable for industrial deployment where reliability and offline access are critical.

\section{Conclusion}

The ESP32 Motor Control System successfully demonstrates the integration of classical control theory with modern IoT architecture, with key innovations in \textbf{dual-mode autotuning}, \textbf{secure cloud communication}, and \textbf{progressive web application design}.

\begin{enumerate}
    \item \textbf{RPM Control}: The system achieved stable bidirectional speed control across the full \textbf{-300 to +300 RPM} range, with the non-linear PWM scaling ensuring consistent performance in both forward and reverse directions.
    
    \item \textbf{Position Control}: The implementation of a dedicated PID loop with deadband logic allows for precise angle holding. Critically, position control now uses \textit{separate autotuned gains} (posKp, posKi, posKd) derived from modified Ziegler-Nichols formulas specifically designed for servo systems, eliminating the integral windup and sustained oscillations that occur when naively applying speed-tuned gains to position control.
    
    \item \textbf{Dual-Mode Autotuning}: The relay-based autotuner recognizes that speed and position control are fundamentally different problems (velocity vs. integrated quantity) and applies appropriate tuning formulas:
    \begin{itemize}
        \item Speed: Standard Ziegler-Nichols ($K_p = 0.6K_u$)
        \item Position: Modified servo formulas ($\text{posKp} = 0.8K_u$, with 4$\times$ lower integral and 2$\times$ higher derivative)
    \end{itemize}
    
    \item \textbf{Secure IoT Communication}: The system implements MQTT over TLS (port 8883) with HiveMQ Cloud, providing encrypted remote control and monitoring. The use of WiFiClientSecure on ESP32 and WebSocket Secure (wss://) on the web dashboard ensures production-grade security. ArduinoJson enables efficient JSON serialization with a 512-byte buffer for telemetry messages.
    
    \item \textbf{Advanced Data Visualization}: The web dashboard provides 8 specialized charts including real-time RPM/PWM monitoring, calibration oscillation capture (100-200 RPM range), and educational PID comparison charts. All charts support CSV export for MATLAB/Python analysis and PNG export for documentation. The auto-scaled Y-axis with integer steps ensures clear visibility of control dynamics.
    
    \item \textbf{PID Mode Comparison}: The system supports dynamic switching between P-only, PI-only, and Full PID modes during runtime, with a dedicated comparison chart that overlays all three responses. This educational feature demonstrates overshoot ($>$20\% for P-only), steady-state error elimination (PI/PID), and optimal damping (Full PID).
    
    \item \textbf{Progressive Web App}: The dashboard is deployed as a PWA with Service Worker caching, enabling offline access, instant loading ($<$1s startup), and native app-like experience. The manifest.json with 8 icon sizes ensures proper installation on all platforms (iOS, Android, Desktop). Cache versioning (v1.4) enables automatic updates.
    
    \item \textbf{Digital Twin Simulation}: The \texttt{mqtt-simulation.js} module provides real-time 2D car simulation driven by MQTT telemetry, where physical motor RPM controls virtual car speed and motor angle controls steering direction. This creates a Hardware-in-the-Loop feel for intuitive system verification.
    
    \item \textbf{Tuning Method Selection}: The comparative analysis confirmed that while Tyler-Rubinson offers superior stability, Ziegler-Nichols provides the responsiveness required for dynamic motor control applications.
\end{enumerate}

\textbf{Key Takeaway:} This project demonstrates that \textit{one-size-fits-all PID tuning} is inadequate for multi-mode control systems. Position and speed control require different gain structures because they regulate different physical quantities (position = $\int$ velocity). Our dual-mode autotuning approach provides optimal performance for both control objectives from a single relay experiment.

This project serves as a robust foundation for more complex robotics applications, such as differential drive robots or robotic arms, where both velocity and position control are essential.

\section{References}
\begin{enumerate}
    \item Astrom, K.J., \& Hagglund, T. (1984). "Automatic Tuning of Simple Regulators with Specifications on Phase and Amplitude Margins".
    \item Ziegler, J.G., \& Nichols, N.B. (1942). "Optimum Settings for Automatic Controllers".
    \item Tyreus, B.D., \& Luyben, W.L. (1992). "Tuning PI Controllers for Integrator/Dead Time Processes".
    \item Espressif Systems. "ESP32 Technical Reference Manual".
\end{enumerate}

\end{document}
